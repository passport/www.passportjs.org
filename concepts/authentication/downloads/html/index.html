<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#" lang="en">
  <head>
    <title>Documentation</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="canonical" href="https://www.passportjs.org/concepts/authentication/downloads/html/">
    <link rel="manifest" href="/manifest.webmanifest"/>
    <meta name="theme-color" content="#35DF79"/>
    <link rel="shortcut icon" href="/images/favicon/favicon.ico"/>
    <link rel="icon" sizes="16x16" type="image/png" href="/images/favicon/favicon-16x16.png"/>
    <link rel="icon" sizes="32x32" type="image/png" href="/images/favicon/favicon-32x32.png"/>
    <link rel="icon" sizes="36x36" type="image/png" href="/images/favicon/android-icon-36x36.png"/>
    <link rel="icon" sizes="48x48" type="image/png" href="/images/favicon/android-icon-48x48.png"/>
    <link rel="icon" sizes="70x70" type="image/png" href="/images/favicon/ms-icon-70x70.png"/>
    <link rel="icon" sizes="72x72" type="image/png" href="/images/favicon/android-icon-72x72.png"/>
    <link rel="icon" sizes="96x96" type="image/png" href="/images/favicon/android-icon-96x96.png"/>
    <link rel="icon" sizes="144x144" type="image/png" href="/images/favicon/ms-icon-144x144.png"/>
    <link rel="icon" sizes="150x150" type="image/png" href="/images/favicon/ms-icon-150x150.png"/>
    <link rel="icon" sizes="192x192" type="image/png" href="/images/favicon/android-icon-192x192.png"/>
    <link rel="icon" sizes="310x310" type="image/png" href="/images/favicon/ms-icon-310x310.png"/>
    <link rel="apple-touch-icon" href="/images/favicon/apple-icon-57x57.png"/>
    <link rel="apple-touch-icon" sizes="60x60" href="/images/favicon/apple-icon-60x60.png"/>
    <link rel="apple-touch-icon" sizes="72x72" href="/images/favicon/apple-icon-72x72.png"/>
    <link rel="apple-touch-icon" sizes="76x76" href="/images/favicon/apple-icon-76x76.png"/>
    <link rel="apple-touch-icon" sizes="114x114" href="/images/favicon/apple-icon-114x114.png"/>
    <link rel="apple-touch-icon" sizes="120x120" href="/images/favicon/apple-icon-120x120.png"/>
    <link rel="apple-touch-icon" sizes="144x144" href="/images/favicon/apple-icon-144x144.png"/>
    <link rel="apple-touch-icon" sizes="152x152" href="/images/favicon/apple-icon-152x152.png"/>
    <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-icon-180x180.png"/>
    <meta name="msapplication-config" content="/browserconfig.xml"/>
    <meta name="msapplication-TileColor" content="#35DF79"/>
    <meta name="msapplication-TileImage" content="/images/favicon/ms-icon-144x144.png"/>
    <meta property="og:type" content="website"/>
    <meta property="og:title" content="Documentation"/>
    <meta property="og:url" content="https://www.passportjs.org/concepts/authentication/downloads/html/"/>
    <meta property="og:image" content="https://www.passportjs.org/images/facebook-card.png"/>
    <meta property="og:image:type" content="image/png"/>
    <meta property="og:image:width" content="1200"/>
    <meta property="og:image:height" content="630"/>
    <meta property="og:site_name" content="Passport.js"/>
    <meta name="twitter:card" content="summary_large_image"/>
    <meta name="twitter:site" content="@passportjs"/>
    <meta name="twitter:title" content="Documentation"/>
    <meta name="twitter:image" content="https://www.passportjs.org/images/twitter-card.png"/>
    <meta name="flattr:id" content="d5znvd"/>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      
      ga('create', 'UA-73332146-2', 'auto');
      ga('send', 'pageview');
    </script>
    <!--+google-tag-manager('GTM-M5S3PH')-->
    <!--link(type='text/css', rel='stylesheet', href='http://fast.fonts.net/cssapi/7527d73a-ebfe-45db-a201-ff2812df4b18.css')-->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/default.min.css">
    <link rel="stylesheet" href="/assets/styles/all.css">
    <script data-main="/script/main" src="//cdnjs.cloudflare.com/ajax/libs/require.js/2.3.5/require.js"></script>
  </head>
  <body>
    <div id="container"><span id="top"></span>
      <div id="toolbar">
        <div class="toolbar-search">
          <form action="/search">
            <button type="submit"></button>
            <input type="text" name="q" placeholder="Search for Strategies">
          </form>
        </div>
        <div class="toolbar-social">
          <ul>
            <li class="facebook"><a href="https://www.facebook.com/passportjs" target="_blank"></a></li>
            <li class="twitter"><a href="https://twitter.com/passportjs" target="_blank"></a></li>
            <li class="github"><a href="https://github.com/jaredhanson/passport" target="_blank"><span class="count">0</span></a></li>
          </ul>
        </div>
      </div>
      <nav id="menu"><a class="menu-logo" href="/" title="Passport.js"></a>
        <div class="menu-trigger"><span></span></div>
        <div class="menu-items">
          <ul>
            <li><a href="/">Home</a></li>
            <li class="active"><a href="/docs/">Documentation</a></li>
            <li><a href="/features/">Features</a></li>
            <li><a href="/packages/">Strategies</a></li>
          </ul><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=passportjsorg" id="_carbonads_js"></script>
        </div>
      </nav>
      <div id="content">
        <div class="book" id="book">
          <div class="toc">
            <nav data-accordion-group="">
              <div class="accordion" data-accordion="">
                <h5 data-control=""><i class="icon-budicon-461"></i><a href="/concepts/authentication/middleware/"></a>General</h5>
                <ul data-content="">
                  <li><a href="/concepts/authentication/middleware/">Middleware</a></li>
                  <li><a href="/concepts/authentication/strategies/">Strategies</a></li>
                  <li><a href="/concepts/authentication/password/">Username &amp; Password</a></li>
                  <li><a href="/concepts/authentication/openid/">OpenID</a></li>
                  <li><a href="/concepts/authentication/oauth/">OAuth</a></li>
                </ul>
              </div>
              <div class="accordion" data-accordion="">
                <h5 data-control=""><i class="icon-budicon-461"></i><a href="/concepts/authentication/facebook/"></a>Providers</h5>
                <ul data-content="">
                  <li><a href="/concepts/authentication/facebook/">Facebook</a></li>
                  <li><a href="/concepts/authentication/twitter/">Twitter</a></li>
                  <li><a href="/concepts/authentication/google/">Google</a></li>
                </ul>
              </div>
              <div class="accordion" data-accordion="">
                <h5 data-control=""><i class="icon-budicon-461"></i><a href="/concepts/authentication/http-basic/"></a>APIs</h5>
                <ul data-content="">
                  <li><a href="/concepts/authentication/http-basic/">Basic &amp; Digest</a></li>
                  <li><a href="/concepts/authentication/http-oauth/">OAuth</a></li>
                  <li><a href="/concepts/authentication/http-bearer/">OAuth 2.0</a></li>
                </ul>
              </div>
              <div class="accordion" data-accordion="">
                <h5 data-control=""><i class="icon-budicon-461"></i><a href="/concepts/authentication/login/"></a>Operations</h5>
                <ul data-content="">
                  <li><a href="/concepts/authentication/login/">Log In</a></li>
                  <li><a href="/concepts/authentication/logout/">Log Out</a></li>
                </ul>
              </div>
            </nav>
          </div><a id="go-top" href="#top"><i class="icon-budicon-462"></i></a>
          <div class="contents"><section class="chapter" id="README"><h1 id="overview">Overview</h1>
<p>Passport is authentication middleware for <a href="https://nodejs.org/">Node.js</a>.  It is
designed to serve a singular purpose: authenticate requests.  Passport cleanly
encapsulates this functionality, while delegating unrelated details such as data
access to the application.  Whether you are building a new application or
working on an existing one, this separation of concerns makes Passport extremely
easy to integrate.</p>
<p>In modern web applications, authentication can be performed in a variety of
ways.  Traditionally, users log in by providing a username and password.  Social
networks, along with the billions of people that have joined them, have made
<a href="https://en.wikipedia.org/wiki/Single_sign-on">single sign-on</a> (SSO) using
<a href="https://www.facebook.com/">Facebook</a> or <a href="https://www.google.com/">Google</a> a
popular option.  Recent innovations, encompassed by <a href="https://en.wikipedia.org/wiki/WebAuthn">Web Authentication</a>
(WebAuthn), allow people to log in using fingerprint or facial recognition.</p>
<p>Application architectures are also constantly evolving.  Application logic that,
in the past, had to execute on the server can now execute in the browser, with
the frontend invoking backend APIs.  Such architectures rely heavily on
token-based credentials to protect access.</p>
<p>Passport reduces the complexity of authenticating a request to a simple
statement:</p>
<pre><code class="lang-javascript">app.post(<span class="string">'/login/password'</span>, passport.authenticate(<span class="string">'local'</span>));
</code></pre>
<p>Hidden behind that simple statement are three fundamental concepts:</p>
<ol>
<li>Middleware</li>
<li>Strategies</li>
<li>Sessions</li>
</ol>
<p>This guide provides an overview of these concepts, explaining how they fit
together within Passport.  Some of the most commonly used authentication
mechanisms will be explored in detail, to illustrate how they are integrated.
After reading this guide, you will have an understanding of how Passport works
when authenticating requests to your application.</p>
</section><section class="chapter" id="middleware"><h1 id="middleware">Middleware</h1>
<p>Passport is used as middleware within a web application to authenticate
requests.  Middleware was popularized in <a href="https://nodejs.org/">Node.js</a> by
<a href="https://expressjs.com/">Express</a> and its even more minimalist sibling <a href="https://github.com/senchalabs/connect">Connect</a>.
Given its popularity, middleware is easily adaptable to other web frameworks.</p>
<p>The following code is an example of a route that authenticates a user with a
username and password:</p>
<pre><code class="lang-javascript">app.post(<span class="string">'/login/password'</span>,
  passport.authenticate(<span class="string">'local'</span>, { <span class="attr">failureRedirect</span>: <span class="string">'/login'</span>, <span class="attr">failureMessage</span>: <span class="literal">true</span> }),
  <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>{
    res.redirect(<span class="string">'/~'</span> + req.user.username);
  });
</code></pre>
<p>In this route, <code>passport.authenticate()</code> is <a href="https://expressjs.com/en/guide/using-middleware.html">middleware</a>
which will authenticate the request.  By default, when authentication succeeds,
the <code>req.user</code> property is set to the authenticated user, a session is
established, and the next function in the stack is called.  This next function
is typically application-specific logic which will process the request on behalf
of the user.</p>
<p>When authentication fails, an HTTP <code>401 Unauthorized</code> response will be sent and
the request-response cycle will end.  Any additional functions in the stack will
not be called.  This default behavior is suitable for APIs obeying <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">representational state transfer</a>
(REST) constaints, and can be modified using options.</p>
<p>The mechanism used to authenticate the request is implemented by a strategy, of
which there can be many.  For instance, authenticating a user with a username
and password entails a different set of operations than authenticating a user
via OpenID Connect, even though both result in the same outcome of an
authenticated user.  In the route above, the <code>local</code> strategy is used to verify
a username and password.</p>
<p>Prior to employing a strategy to authenticate a request, the strategy must be
installed and configured.  This brings us to our <a href="/docs/configure/">next</a> topic.</p>
</section><section class="chapter" id="strategies"><h1 id="strategies">Strategies</h1>
<p>Strategies are responsible for authenticating requests, which they accomplish by
implementing an authentication mechanism.  Authentication mechanisms define how
to encode a credential, such as a password or an assertion from an identity
provider (IdP), in a request.  They also specify the procedure necessary to
verify that credential.  If the credential is successfully verified, the request
is authenticated.</p>
<p>There are a wide variety of authentication mechanisms, and a corresponding
variety of strategies.  Strategies are distributed in separate packages which
must be installed, configured, and registered.</p>
<h2 id="install">Install</h2>
<p>Strategies are published to the <a href="https://www.npmjs.com/">npm</a> registry, and
installed using a package manager.</p>
<p>The following command will install <a href="https://www.passportjs.org/packages/passport-local/"><code>passport-local</code></a>,
a package which provides a strategy for authenticating with a username and
password:</p>
<pre><code class="lang-bash">$ npm install passport-local
</code></pre>
<p>The following command will install <a href="https://www.passportjs.org/packages/passport-openidconnect/"><code>passport-openidconnect</code></a>,
a package which implements support for <a href="https://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect</a>:</p>
<pre><code class="lang-bash">$ npm install passport-openidconnect
</code></pre>
<p>Developers only need to install the packages which provide authentication
mechanisms required by the application.  This reduces overall application size
by avoiding unnecessary dependencies.</p>
<h2 id="configure">Configure</h2>
<p>Once a package has been installed, the strategy needs to be configured.  The
configuration varies with each authentication mechanism, so strategy-specific
documentation should be consulted.  That being said, there are common patterns
that are encountered across many strategies.</p>
<p>The following code is an example that configures the <code>LocalStrategy</code>:</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> LocalStrategy = <span class="built_in">require</span>(<span class="string">'passport-local'</span>);

<span class="keyword">var</span> strategy = <span class="keyword">new</span> LocalStrategy(<span class="function"><span class="keyword">function</span> <span class="title">verify</span>(<span class="params">username, password, cb</span>) </span>{
  db.get(<span class="string">'SELECT * FROM users WHERE username = ?'</span>, [ username ], <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>{
    <span class="keyword">if</span> (err) { <span class="keyword">return</span> cb(err); }
    <span class="keyword">if</span> (!user) { <span class="keyword">return</span> cb(<span class="literal">null</span>, <span class="literal">false</span>, { <span class="attr">message</span>: <span class="string">'Incorrect username or password.'</span> }); }

    crypto.pbkdf2(password, user.salt, <span class="number">310000</span>, <span class="number">32</span>, <span class="string">'sha256'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, hashedPassword</span>) </span>{
      <span class="keyword">if</span> (err) { <span class="keyword">return</span> cb(err); }
      <span class="keyword">if</span> (!crypto.timingSafeEqual(user.hashed_password, hashedPassword)) {
        <span class="keyword">return</span> cb(<span class="literal">null</span>, <span class="literal">false</span>, { <span class="attr">message</span>: <span class="string">'Incorrect username or password.'</span> });
      }
      <span class="keyword">return</span> cb(<span class="literal">null</span>, user);
    });
  });
});
</code></pre>
<h4 id="verify-function">Verify Function</h4>
<p>The <code>LocalStrategy</code> constructor takes a function as an argument.  This function
is known as a <code>verify</code> function, and is a common pattern in many strategies.
When authenticating a request, a strategy parses the credential contained in the
request.  A <code>verify</code> function is then called, which is responsible for
determining the user to which that credential belongs.  This allows data access
to be delegated to the application.</p>
<p>In this particular example, the <code>verify</code> function is executing a SQL query to
obtain a user record from the database and, after verifying the password,
yielding the record back to the strategy, thus authenticating the user and
establishing a session.</p>
<p>Because a <code>verify</code> function is supplied by the application itself, access to
persistent storage is not constrained in any way.  The application is free to
use any data storage system, including relational databases, graph databases,
or document stores, and structure data within that store according to any
schema.</p>
<p>A <code>verify</code> function is strategy-specific, and the exact arguments it receives
and parameters it yields will depend on the underlying authentication mechanism.
For authentication mechanisms involving shared secrets, such as a password, a
<code>verify</code> function is responsible for verifying the credential and yielding a
user.  For mechanisms that provide cryptographic authentication, a <code>verify</code>
function will typically yield a user and a key, the later of which the strategy
will use to cryptographically verify the credential.</p>
<p>A <code>verify</code> function yields under one of three conditions: success, failure, or
an error.</p>
<p>If the <code>verify</code> function finds a user to which the credential belongs, and that
credential is valid, it calls the callback with the authenticating user:</p>
<pre><code class="lang-javascript"><span class="keyword">return</span> cb(<span class="literal">null</span>, user);
</code></pre>
<p>If the credential does not belong to a known user, or is not valid, the <code>verify</code>
function calls the callback with <code>false</code> to indicate an authentication failure:</p>
<pre><code class="lang-javascript"><span class="keyword">return</span> cb(<span class="literal">null</span>, <span class="literal">false</span>);
</code></pre>
<p>If an error occurs, such as the database not being available, the callback is
called with an error, in idiomatic Node.js style:</p>
<pre><code class="lang-javascript"><span class="keyword">return</span> cb(err);
</code></pre>
<p>It is important to distinguish between the two failure cases that can occur.
Authentication failures are expected conditions, in which the server is
operating normally, even though invalid credentials are being received from the
user (or a malicious adversary attempting to authenticate as the user).  Only
when the server is operating abnormally should <code>err</code> be set, to indicate an
internal error.</p>
<h2 id="register">Register</h2>
<p>With the strategy configured, it is then registered by calling <code>.use()</code>:</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>);

passport.use(strategy);
</code></pre>
<p>All strategies have a name which, by convention, corresponds to the package
name according to the pattern <code>passport-{name}</code>.  For instance, the
<code>LocalStrategy</code> configured above is named <code>local</code> as it is distributed in the
<code>passport-local</code> package.</p>
<p>Once registered, the strategy can be employed to authenticate a request by
passing the name of the strategy as the first argument to <code>passport.authenticate()</code>
middleware:</p>
<pre><code class="lang-javascript">app.post(<span class="string">'/login/password'</span>,
  passport.authenticate(<span class="string">'local'</span>, { <span class="attr">failureRedirect</span>: <span class="string">'/login'</span>, <span class="attr">failureMessage</span>: <span class="literal">true</span> }),
  <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>{
    res.redirect(<span class="string">'/~'</span> + req.user.username);
  });
</code></pre>
<p>In cases where there is a naming conflict, or the default name is not
sufficiently descriptive, the name can be overridden when registering the
strategy by passing a name as the first argument to <code>.use()</code>:</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>);

passport.use(<span class="string">'password'</span>, strategy);
</code></pre>
<p>That name is then specified to <code>passport.authenticate()</code> middleware:</p>
<pre><code class="lang-javascript">app.post(<span class="string">'/login/password'</span>,
  passport.authenticate(<span class="string">'password'</span>, { <span class="attr">failureRedirect</span>: <span class="string">'/login'</span>, <span class="attr">failureMessage</span>: <span class="literal">true</span> }),
  <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>{
    res.redirect(<span class="string">'/~'</span> + req.user.username);
  });
</code></pre>
<p>For brevity, strategies are often configured and registered in a single
statement:</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>);
<span class="keyword">var</span> LocalStrategy = <span class="built_in">require</span>(<span class="string">'passport-local'</span>);

passport.use(<span class="keyword">new</span> LocalStrategy(<span class="function"><span class="keyword">function</span> <span class="title">verify</span>(<span class="params">username, password, cb</span>) </span>{
  <span class="comment">// ...</span>
});
</code></pre>
</section><section class="chapter" id="password"><h1 id="username-password">Username &amp; Password</h1>
<p>A username and password is the traditional, and still most widely used, way for
users to authenticate to a website.  Support for this mechanism is provided by
the <a href="https://www.passportjs.org/packages/passport-local/"><code>passport-local</code></a>
package.</p>
<h2 id="install">Install</h2>
<p>To install <code>passport-local</code>, execute the following command:</p>
<pre><code class="lang-bash">$ npm install passport-local
</code></pre>
<h2 id="configure">Configure</h2>
<p>The following code is an example that configures and registers the
<code>LocalStrategy</code>:</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>);
<span class="keyword">var</span> LocalStrategy = <span class="built_in">require</span>(<span class="string">'passport-local'</span>);
<span class="keyword">var</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);

passport.use(<span class="keyword">new</span> LocalStrategy(<span class="function"><span class="keyword">function</span> <span class="title">verify</span>(<span class="params">username, password, cb</span>) </span>{
  db.get(<span class="string">'SELECT * FROM users WHERE username = ?'</span>, [ username ], <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>{
    <span class="keyword">if</span> (err) { <span class="keyword">return</span> cb(err); }
    <span class="keyword">if</span> (!user) { <span class="keyword">return</span> cb(<span class="literal">null</span>, <span class="literal">false</span>, { <span class="attr">message</span>: <span class="string">'Incorrect username or password.'</span> }); }

    crypto.pbkdf2(password, user.salt, <span class="number">310000</span>, <span class="number">32</span>, <span class="string">'sha256'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, hashedPassword</span>) </span>{
      <span class="keyword">if</span> (err) { <span class="keyword">return</span> cb(err); }
      <span class="keyword">if</span> (!crypto.timingSafeEqual(user.hashed_password, hashedPassword)) {
        <span class="keyword">return</span> cb(<span class="literal">null</span>, <span class="literal">false</span>, { <span class="attr">message</span>: <span class="string">'Incorrect username or password.'</span> });
      }
      <span class="keyword">return</span> cb(<span class="literal">null</span>, user);
    });
  });
});
</code></pre>
<p>The <code>LocalStrategy</code> constructor takes a <code>verify</code> function as an argument, which
accepts <code>username</code> and <code>password</code> as arguments.  When authenticating a request,
the strategy parses a username and password, which are submitted via an HTML
form to the web application.  The strategy then calls the <code>verify</code> function with
those credentials.</p>
<p>The <code>verify</code> function is responsible for determining the user to which the
username belongs, as well as verifying the password.  Because the <code>verify</code>
function is supplied by the application, the application is free to use a
database and schema of its choosing.  The example above illustrates usage of a
SQL database.</p>
<p>Similarly, the application is free to determine its password storage format.
The example above illustrates usage of <a href="https://datatracker.ietf.org/doc/html/rfc2898">PBKDF2</a>
when comparing the user-supplied password with the hashed password stored in the
database.</p>
<p>In case of authentication failure, the <code>verify</code> callback supplies a message, via
the <code>message</code> option, describing why authentication failed.  This will be
displayed to the user when they are re-prompted to sign in, informing them of
what went wrong.</p>
<h2 id="prompt">Prompt</h2>
<p>The user is prompted to sign in with their username and password by rendering a
form.  This is accomplished by defining a route:</p>
<pre><code class="lang-javascript">app.get(<span class="string">'/login'</span>,
  <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>{
    res.render(<span class="string">'login'</span>);
  });
</code></pre>
<p>The following form is an example which uses <a href="https://web.dev/sign-in-form-best-practices/">best practices</a>:</p>
<pre><code class="lang-html"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/login/password"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span>
    <span class="tag">&lt;<span class="name">div</span>&gt;</span>
        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"username"</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span>
        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">autocomplete</span>=<span class="string">"username"</span> <span class="attr">required</span> /&gt;</span>
    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>
    <span class="tag">&lt;<span class="name">div</span>&gt;</span>
        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"current-password"</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">label</span>&gt;</span>
        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"current-password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">autocomplete</span>=<span class="string">"current-password"</span> <span class="attr">required</span> /&gt;</span>
    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>
    <span class="tag">&lt;<span class="name">div</span>&gt;</span>
        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Sign in<span class="tag">&lt;/<span class="name">button</span>&gt;</span>
    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>
<span class="tag">&lt;/<span class="name">form</span>&gt;</span>
</code></pre>
<h2 id="authenticate">Authenticate</h2>
<p>When the user submits the form, it is processed by a route that authenticates
the user using the username and password they entered.</p>
<pre><code class="lang-javascript">app.post(<span class="string">'/login/password'</span>,
  passport.authenticate(<span class="string">'local'</span>, { <span class="attr">failureRedirect</span>: <span class="string">'/login'</span>, <span class="attr">failureMessage</span>: <span class="literal">true</span> }),
  <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>{
    res.redirect(<span class="string">'/~'</span> + req.user.username);
  });
</code></pre>
<p>If authentication succeeds, <code>passport.authenticate()</code> middleware calls the next
function in the stack.  In this example, the function is redirecting the
authenticated user to their profile page.</p>
<p>When authentication fails, the user is re-prompted to sign in and informed that
their initial attempt was not successful.  This is accomplished by using the
<code>failureRedirect</code> option, which will redirect the user to the login page, along
with the <code>failureMessage</code> option which will add the message to
<code>req.session.messages</code>.</p>
</section><section class="chapter" id="openid"><h1 id="openid">OpenID</h1>
<p><a href="http://openid.net/">OpenID</a> is an open standard for federated authentication.
When visiting a website, users present their OpenID to sign in.  The user then
authenticates with their chosen OpenID provider, which issues an assertion to
confirm the user&#39;s identity.  The website verifies this assertion in order to
sign the user in.</p>
<p>Support for OpenID is provided by the <a href="https://github.com/jaredhanson/passport-openid">passport-openid</a>
module.</p>
<h2 id="install">Install</h2>
<pre><code class="lang-bash">$ npm install passport-openid
</code></pre>
<h2 id="configuration">Configuration</h2>
<p>When using OpenID, a return URL and realm must be specified.  The <code>returnURL</code> is
the URL to which the user will be redirected after authenticating with their
OpenID provider.  <code>realm</code> indicates the part of URL-space for which
authentication is valid.  Typically this will be the root URL of the website.</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>)
  , OpenIDStrategy = <span class="built_in">require</span>(<span class="string">'passport-openid'</span>).Strategy;

passport.use(<span class="keyword">new</span> OpenIDStrategy({
    <span class="attr">returnURL</span>: <span class="string">'http://www.example.com/auth/openid/return'</span>,
    <span class="attr">realm</span>: <span class="string">'http://www.example.com/'</span>
  },
  <span class="function"><span class="keyword">function</span>(<span class="params">identifier, done</span>) </span>{
    User.findOrCreate({ <span class="attr">openId</span>: identifier }, <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>{
      done(err, user);
    });
  }
));
</code></pre>
<p>The verify callback for OpenID authentication accepts an <code>identifier</code> argument
containing the user&#39;s claimed identifier.</p>
<h2 id="form">Form</h2>
<p>A form is placed on a web page, allowing the user to enter their OpenID and
sign in.</p>
<pre><code class="lang-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/auth/openid"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span>
    <span class="tag">&lt;<span class="name">div</span>&gt;</span>
        <span class="tag">&lt;<span class="name">label</span>&gt;</span>OpenID:<span class="tag">&lt;/<span class="name">label</span>&gt;</span>
        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"openid_identifier"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span>
    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>
    <span class="tag">&lt;<span class="name">div</span>&gt;</span>
        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Sign In"</span>/&gt;</span>
    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>
<span class="tag">&lt;/<span class="name">form</span>&gt;</span>
</code></pre>
<h2 id="routes">Routes</h2>
<p>Two routes are required for OpenID authentication.  The first route accepts the
form submission containing an OpenID identifier.  During authentication, the
user will be redirected to their OpenID provider.  The second route is the URL
to which the user will be returned after authenticating with their OpenID
provider.</p>
<pre><code class="lang-javascript"><span class="comment">// Accept the OpenID identifier and redirect the user to their OpenID</span>
<span class="comment">// provider for authentication.  When complete, the provider will redirect</span>
<span class="comment">// the user back to the application at:</span>
<span class="comment">//     /auth/openid/return</span>
app.post(<span class="string">'/auth/openid'</span>, passport.authenticate(<span class="string">'openid'</span>));

<span class="comment">// The OpenID provider has redirected the user back to the application.</span>
<span class="comment">// Finish the authentication process by verifying the assertion.  If valid,</span>
<span class="comment">// the user will be logged in.  Otherwise, authentication has failed.</span>
app.get(<span class="string">'/auth/openid/return'</span>,
  passport.authenticate(<span class="string">'openid'</span>, { <span class="attr">successRedirect</span>: <span class="string">'/'</span>,
                                    <span class="attr">failureRedirect</span>: <span class="string">'/login'</span> }));
</code></pre>
<h2 id="profile-exchange">Profile Exchange</h2>
<p>OpenID can optionally be configured to retrieve profile information about the
user being authenticated.  Profile exchange is enabled by setting the <code>profile</code>
option to <code>true</code>.</p>
<pre><code class="lang-javascript">passport.use(<span class="keyword">new</span> OpenIDStrategy({
    <span class="attr">returnURL</span>: <span class="string">'http://www.example.com/auth/openid/return'</span>,
    <span class="attr">realm</span>: <span class="string">'http://www.example.com/'</span>,
    <span class="attr">profile</span>: <span class="literal">true</span>
  },
  <span class="function"><span class="keyword">function</span>(<span class="params">identifier, profile, done</span>) </span>{
    <span class="comment">// ...</span>
  }
));
</code></pre>
<p>When profile exchange is enabled, the function signature of the verify callback
accepts an additional <code>profile</code> argument containing user profile information
provided by the OpenID provider; refer to <a href="/guide/profile/">User Profile</a> for
further information.</p>
</section><section class="chapter" id="oauth"><h1 id="oauth">OAuth</h1>
<p><a href="http://oauth.net/">OAuth</a> is a standard protocol that allows users to authorize
API access to web and desktop or mobile applications.  Once access has been
granted, the authorized application can utilize the API on behalf of the user.
OAuth has also emerged as a popular mechanism for <a href="https://web.archive.org/web/20160322014955/http://hueniverse.com/2009/04/16/introducing-sign-in-with-twitter-oauth-style-connect/">delegated authentication</a>.</p>
<p>OAuth comes in two primary flavors, both of which are widely deployed.</p>
<p>The initial version of OAuth was developed as an open standard by a loosely
organized collective of web developers.  Their work resulted in <a href="http://oauth.net/core/1.0/">OAuth 1.0</a>,
which was superseded by <a href="http://oauth.net/core/1.0a/">OAuth 1.0a</a>.  This work
has now been standardized by the <a href="http://www.ietf.org/">IETF</a> as <a href="http://tools.ietf.org/html/rfc5849">RFC 5849</a>.</p>
<p>Recent efforts undertaken by the <a href="http://tools.ietf.org/wg/oauth/">Web Authorization Protocol Working Group</a>
have focused on defining <a href="http://tools.ietf.org/html/rfc6749">OAuth 2.0</a>.  Due
to the lengthy standardization effort, providers have proceeded to deploy
implementations conforming to various drafts, each with slightly different
semantics.</p>
<p>Thankfully, Passport shields an application from the complexities of dealing
with OAuth variants.  In many cases, a provider-specific strategy can be used
instead of the generic OAuth strategies described below.  This cuts down on the
necessary configuration, and accommodates any provider-specific quirks. See
<a href="/docs#facebook">Facebook</a>, <a href="/docs#twitter">Twitter</a> or the list of
<a href="" data-search>providers</a> for preferred usage.</p>
<p>Support for OAuth is provided by the <a href="https://github.com/jaredhanson/passport-oauth">passport-oauth</a>
module.</p>
<h2 id="install">Install</h2>
<pre><code class="lang-bash">$ npm install passport-oauth
</code></pre>
<h3 id="oauth-1-0">OAuth 1.0</h3>
<p>OAuth 1.0 is a delegated authentication strategy that involves multiple steps.
First, a request token must be obtained.  Next, the user is redirected to the
service provider to authorize access.  Finally, after authorization has been
granted, the user is redirected back to the application and the request token
can be exchanged for an access token.  The application requesting access, known
as a <em>consumer</em>, is identified by a consumer key and consumer secret.</p>
<h2 id="configuration">Configuration</h2>
<p>When using the generic OAuth strategy, the key, secret, and endpoints are
specified as options.</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>)
  , OAuthStrategy = <span class="built_in">require</span>(<span class="string">'passport-oauth'</span>).OAuthStrategy;

passport.use(<span class="string">'provider'</span>, <span class="keyword">new</span> OAuthStrategy({
    <span class="attr">requestTokenURL</span>: <span class="string">'https://www.provider.com/oauth/request_token'</span>,
    <span class="attr">accessTokenURL</span>: <span class="string">'https://www.provider.com/oauth/access_token'</span>,
    <span class="attr">userAuthorizationURL</span>: <span class="string">'https://www.provider.com/oauth/authorize'</span>,
    <span class="attr">consumerKey</span>: <span class="string">'123-456-789'</span>,
    <span class="attr">consumerSecret</span>: <span class="string">'shhh-its-a-secret'</span>,
    <span class="attr">callbackURL</span>: <span class="string">'https://www.example.com/auth/provider/callback'</span>
  },
  <span class="function"><span class="keyword">function</span>(<span class="params">token, tokenSecret, profile, done</span>) </span>{
    User.findOrCreate(..., <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>{
      done(err, user);
    });
  }
));
</code></pre>
<p>The verify callback for OAuth-based strategies accepts <code>token</code>, <code>tokenSecret</code>,
and <code>profile</code> arguments.  <code>token</code> is the access token and <code>tokenSecret</code> is its
corresponding secret.  <code>profile</code> will contain user profile information provided
by the service provider; refer to <a href="/guide/profile/">User Profile</a> for
additional information.</p>
<h2 id="routes">Routes</h2>
<p>Two routes are required for OAuth authentication.  The first route initiates an
OAuth transaction and redirects the user to the service provider.  The second
route is the URL to which the user will be redirected after authenticating with
the provider.</p>
<pre><code class="lang-javascript"><span class="comment">// Redirect the user to the OAuth provider for authentication.  When</span>
<span class="comment">// complete, the provider will redirect the user back to the application at</span>
<span class="comment">//     /auth/provider/callback</span>
app.get(<span class="string">'/auth/provider'</span>, passport.authenticate(<span class="string">'provider'</span>));

<span class="comment">// The OAuth provider has redirected the user back to the application.</span>
<span class="comment">// Finish the authentication process by attempting to obtain an access</span>
<span class="comment">// token.  If authorization was granted, the user will be logged in.</span>
<span class="comment">// Otherwise, authentication has failed.</span>
app.get(<span class="string">'/auth/provider/callback'</span>,
  passport.authenticate(<span class="string">'provider'</span>, { <span class="attr">successRedirect</span>: <span class="string">'/'</span>,
                                      <span class="attr">failureRedirect</span>: <span class="string">'/login'</span> }));
</code></pre>
<h2 id="link">Link</h2>
<p>A link or button can be placed on a web page, which will start the
authentication process when clicked.</p>
<pre><code class="lang-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/auth/provider"</span>&gt;</span>Log In with OAuth Provider<span class="tag">&lt;/<span class="name">a</span>&gt;</span>
</code></pre>
<h3 id="oauth-2-0">OAuth 2.0</h3>
<p>OAuth 2.0 is the successor to OAuth 1.0, and is designed to overcome perceived
shortcomings in the earlier version.  The authentication flow is essentially the
same.  The user is first redirected to the service provider to authorize access.
After authorization has been granted, the user is redirected back to the
application with a code that can be exchanged for an access token.  The
application requesting access, known as a <em>client</em>, is identified by an ID and
secret.</p>
<h2 id="configuration">Configuration</h2>
<p>When using the generic OAuth 2.0 strategy, the client ID, client secret, and
endpoints are specified as options.</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>)
  , OAuth2Strategy = <span class="built_in">require</span>(<span class="string">'passport-oauth'</span>).OAuth2Strategy;

passport.use(<span class="string">'provider'</span>, <span class="keyword">new</span> OAuth2Strategy({
    <span class="attr">authorizationURL</span>: <span class="string">'https://www.provider.com/oauth2/authorize'</span>,
    <span class="attr">tokenURL</span>: <span class="string">'https://www.provider.com/oauth2/token'</span>,
    <span class="attr">clientID</span>: <span class="string">'123-456-789'</span>,
    <span class="attr">clientSecret</span>: <span class="string">'shhh-its-a-secret'</span>
    <span class="attr">callbackURL</span>: <span class="string">'https://www.example.com/auth/provider/callback'</span>
  },
  <span class="function"><span class="keyword">function</span>(<span class="params">accessToken, refreshToken, profile, done</span>) </span>{
    User.findOrCreate(..., <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>{
      done(err, user);
    });
  }
));
</code></pre>
<p>The verify callback for OAuth 2.0-based strategies accepts <code>accessToken</code>,
<code>refreshToken</code>, and <code>profile</code> arguments.  <code>refreshToken</code> can be used to obtain
new access tokens, and may be <code>undefined</code> if the provider does not issue refresh
tokens.  <code>profile</code> will contain user profile information provided by the service
provider; refer to <a href="/guide/profile/">User Profile</a> for additional information.</p>
<h2 id="routes">Routes</h2>
<p>Two routes are required for OAuth 2.0 authentication.  The first route redirects
the user to the service provider.  The second route is the URL to which the user
will be redirected after authenticating with the provider.</p>
<pre><code class="lang-javascript"><span class="comment">// Redirect the user to the OAuth 2.0 provider for authentication.  When</span>
<span class="comment">// complete, the provider will redirect the user back to the application at</span>
<span class="comment">//     /auth/provider/callback</span>
app.get(<span class="string">'/auth/provider'</span>, passport.authenticate(<span class="string">'provider'</span>));

<span class="comment">// The OAuth 2.0 provider has redirected the user back to the application.</span>
<span class="comment">// Finish the authentication process by attempting to obtain an access</span>
<span class="comment">// token.  If authorization was granted, the user will be logged in.</span>
<span class="comment">// Otherwise, authentication has failed.</span>
app.get(<span class="string">'/auth/provider/callback'</span>,
  passport.authenticate(<span class="string">'provider'</span>, { <span class="attr">successRedirect</span>: <span class="string">'/'</span>,
                                      <span class="attr">failureRedirect</span>: <span class="string">'/login'</span> }));
</code></pre>
<h2 id="scope">Scope</h2>
<p>When requesting access using OAuth 2.0, the scope of access is controlled by the
scope option.</p>
<pre><code class="lang-javascript">app.get(<span class="string">'/auth/provider'</span>,
  passport.authenticate(<span class="string">'provider'</span>, { <span class="attr">scope</span>: <span class="string">'email'</span> })
);
</code></pre>
<p>Multiple scopes can be specified as an array.</p>
<pre><code class="lang-javascript">app.get(<span class="string">'/auth/provider'</span>,
  passport.authenticate(<span class="string">'provider'</span>, { <span class="attr">scope</span>: [<span class="string">'email'</span>, <span class="string">'sms'</span>] })
);
</code></pre>
<p>Values for the <code>scope</code> option are provider-specific.  Consult the provider&#39;s
documentation for details regarding supported scopes.</p>
<h2 id="link">Link</h2>
<p>A link or button can be placed on a web page, which will start the
authentication process when clicked.</p>
<pre><code class="lang-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/auth/provider"</span>&gt;</span>Log In with OAuth 2.0 Provider<span class="tag">&lt;/<span class="name">a</span>&gt;</span>
</code></pre>
</section><section class="chapter" id="facebook"><h1 id="facebook">Facebook</h1>
<p><a href="https://developers.facebook.com/docs/facebook-login/">Facebook Login</a> allows
users to sign in using their Facebook account.  Support for Faceboook Login is
provided by the <a href="https://www.passportjs.org/packages/passport-facebook/"><code>passport-facebook</code></a>
package.</p>
<h2 id="install">Install</h2>
<p>To install <code>passport-facebook</code>, execute the following command:</p>
<pre><code class="lang-bash">$ npm install passport-facebook
</code></pre>
<h2 id="configure">Configure</h2>
<p>Before your application can make use of Facebook Login, you must register your
app with Facebook.  This can be done in the <a href="https://developers.facebook.com/apps">App dashboard</a>
at <a href="https://developers.facebook.com/">Facebook for Developers</a>.  Once
registered, your app will be issued an app ID and secret which will be used in
the strategy configuration.</p>
<p>The following code is an example that configures and registers the
<code>FacebookStrategy</code>:</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>);
<span class="keyword">var</span> FacebookStrategy = <span class="built_in">require</span>(<span class="string">'passport-facebook'</span>);

passport.use(<span class="keyword">new</span> FacebookStrategy({
    <span class="attr">clientID</span>: process.env[<span class="string">'FACEBOOK_APP_ID'</span>],
    <span class="attr">clientSecret</span>: process.env[<span class="string">'FACEBOOK_APP_SECRET'</span>],
    <span class="attr">callbackURL</span>: <span class="string">'https://www.example.com/oauth2/redirect/facebook'</span>
  },
  <span class="function"><span class="keyword">function</span>(<span class="params">accessToken, refreshToken, profile, cb</span>) </span>{
    db.get(<span class="string">'SELECT * FROM federated_credentials WHERE provider = ? AND subject = ?'</span>, [
      <span class="string">'https://www.facebook.com'</span>,
      profile.id
    ], <span class="function"><span class="keyword">function</span>(<span class="params">err, cred</span>) </span>{
      <span class="keyword">if</span> (err) { <span class="keyword">return</span> cb(err); }
      <span class="keyword">if</span> (!cred) {
        <span class="comment">// The Facebook account has not logged in to this app before.  Create a</span>
        <span class="comment">// new user record and link it to the Facebook account.</span>
        db.run(<span class="string">'INSERT INTO users (name) VALUES (?)'</span>, [
          profile.displayName
        ], <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>{
          <span class="keyword">if</span> (err) { <span class="keyword">return</span> cb(err); }

          <span class="keyword">var</span> id = <span class="keyword">this</span>.lastID;
          db.run(<span class="string">'INSERT INTO federated_credentials (user_id, provider, subject) VALUES (?, ?, ?)'</span>, [
            id,
            <span class="string">'https://www.facebook.com'</span>,
            profile.id
          ], <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>{
            <span class="keyword">if</span> (err) { <span class="keyword">return</span> cb(err); }
            <span class="keyword">var</span> user = {
              <span class="attr">id</span>: id.toString(),
              <span class="attr">name</span>: profile.displayName
            };
            <span class="keyword">return</span> cb(<span class="literal">null</span>, user);
          });
        });
      } <span class="keyword">else</span> {
        <span class="comment">// The Facebook account has previously logged in to the app.  Get the</span>
        <span class="comment">// user record linked to the Facebook account and log the user in.</span>
        db.get(<span class="string">'SELECT * FROM users WHERE id = ?'</span>, [ cred.user_id ], <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>{
          <span class="keyword">if</span> (err) { <span class="keyword">return</span> cb(err); }
          <span class="keyword">if</span> (!user) { <span class="keyword">return</span> cb(<span class="literal">null</span>, <span class="literal">false</span>); }
          <span class="keyword">return</span> cb(<span class="literal">null</span>, user);
        });
      }
    };
  }
));
</code></pre>
<p>The options to the <code>FacebookStrategy</code> constructor must include a <code>clientID</code> and
<code>clientSecret</code>, the values of which are set to the app ID and secret that were
obtained when registering your application.  A <code>callbackURL</code> must also be
included.  Facebook will redirect users to this location after they have
authenticated.  The path of this URL must match the route defined below.</p>
<p>The <code>verify</code> function accepts an <code>accessToken</code>, <code>refreshToken</code> and <code>profile</code> as
arguments.  <code>accessToken</code> and <code>refreshToken</code> are used for API access, and are
not needed for authentication.  <code>profile</code> is a <a href="/guide/profile/">normalized</a>
profile containing information provided by Facebook about the user who is
signing in.</p>
<p>The <code>verify</code> function is responsible for determining the user to which the
Facebook account belongs.  The first time that account is used to sign in, a new
user record is typically created automatically using profile information
supplied by Facebook, and that record is then linked to the Facebook account.
On subsequent signins, the existing user record will be found via its relation
to the Facebook account.</p>
<p>Linking social accounts to a user record is recommended, as it allows users to
link multiple social accounts from other providers in the event that they stop
using Facebook.  Alternatively, the user could set up a credential, such as a
password, for their user account at your app.  Either feature allows the user to
continue to sign in to your application independent of their Facebook account.</p>
<p>The example above illustrates usage of a SQL database to find or create a user
record and link it to a Facebook account.  However, because the <code>verify</code>
function is supplied by the application, the application is free to use a
database and schema of its choosing.</p>
<p>Internally, Facebook Login is implemented using <a href="https://developers.facebook.com/docs/facebook-login/manually-build-a-login-flow">OAuth 2.0</a>.
As such, the strategy configuration is able to make use of additional options
and functionality provided by the base <a href="/docs/oauth/">OAuth 2.0 strategy</a>.</p>
<h2 id="prompt">Prompt</h2>
<p>Place a button on the application&#39;s login page, prompting the user to sign in
with Facebook.</p>
<pre><code class="lang-html"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/login/facebook"</span> <span class="attr">class</span>=<span class="string">"button"</span>&gt;</span>Log In With Facebook<span class="tag">&lt;/<span class="name">a</span>&gt;</span>
</code></pre>
<p>Define a route that, when the button is clicked, will redirect the user to
Facebook, where they will authenticate.</p>
<pre><code class="lang-javascript">app.get(<span class="string">'/login/facebook'</span>, passport.authenticate(<span class="string">'facebook'</span>));
</code></pre>
<p>If your application needs additional permissions from the user, they can be
requested with the <code>scope</code> option:</p>
<pre><code class="lang-javascript">app.get(<span class="string">'/login/facebook'</span>, passport.authenticate(<span class="string">'facebook'</span>, {
  <span class="attr">scope</span>: [ <span class="string">'email'</span>, <span class="string">'user_location'</span> ]
}));
</code></pre>
<h2 id="authenticate">Authenticate</h2>
<p>After the user has authenticated with Facebook, they will be redirected back
to your application.  Define a route which will handle this redirect.</p>
<pre><code>app.get(<span class="string">'/oauth2/redirect/facebook'</span>,
  passport.authenticate(<span class="string">'facebook'</span>, { failureRedirect: <span class="string">'/login'</span>, failureMessage: <span class="literal">true</span> }),
  <span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> </span>{
    res.redirect(<span class="string">'/'</span>);
  });
</code></pre><p>When a request to this route is processed, the strategy will authenticate the
fact that the user signed in with Facebook and obtain that user&#39;s profile
information.  If authentication succeeds, <code>passport.authenticate()</code> middleware
calls the next function in the stack.  In this example, the function is
redirecting the authenticated user to the home page.</p>
<p>When authentication fails, the user is re-prompted to sign in and informed that
their initial attempt was not successful.  This is accomplished by using the
<code>failureRedirect</code> option, which will redirect the user to the login page, along
with the <code>failureMessage</code> option which will add the message to
<code>req.session.messages</code>.</p>
<p>The path of this route should be the value supplied for the <code>callbackURL</code> option
in the strategy configuration above.</p>
</section><section class="chapter" id="twitter"><h1 id="twitter">Twitter</h1>
<p><a href="https://developer.twitter.com/en/docs/authentication/guides/log-in-with-twitter">Log in with Twitter</a>
allows users to sign in using their Twitter account.  Support for Log in with
Twitter is provided by the <a href="https://www.passportjs.org/packages/passport-twitter/"><code>passport-twitter</code></a>
package.</p>
<h2 id="install">Install</h2>
<p>To install <code>passport-twitter</code>, execute the following command:</p>
<pre><code class="lang-bash">$ npm install passport-twitter
</code></pre>
<h2 id="configure">Configure</h2>
<p>Before your application can make use of Log in with Twitter, you must register
your app with Twitter.  This can be done in the <a href="https://developer.twitter.com/en/apps">Apps dashboard</a>
at <a href="https://developer.twitter.com/">Twitter Developer Platform</a>.  Once
registered, your app will be issued an API key and secret which will be used in
the strategy configuration.</p>
<p>The following code is an example that configures and registers the
<code>TwitterStrategy</code>:</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>)
<span class="keyword">var</span> TwitterStrategy = <span class="built_in">require</span>(<span class="string">'passport-twitter'</span>);

passport.use(<span class="keyword">new</span> TwitterStrategy({
    <span class="attr">consumerKey</span>: process.env[<span class="string">'TWITTER_API_KEY'</span>],
    <span class="attr">consumerSecret</span>: process.env[<span class="string">'TWITTER_API_SECRET'</span>],
    <span class="attr">callbackURL</span>: <span class="string">'http://www.example.com/oauth/callback/twitter'</span>
  },
  <span class="function"><span class="keyword">function</span>(<span class="params">token, tokenSecret, profile, done</span>) </span>{
    db.get(<span class="string">'SELECT * FROM federated_credentials WHERE provider = ? AND subject = ?'</span>, [
      <span class="string">'https://twitter.com'</span>,
      profile.id
    ], <span class="function"><span class="keyword">function</span>(<span class="params">err, cred</span>) </span>{
      <span class="keyword">if</span> (err) { <span class="keyword">return</span> cb(err); }
      <span class="keyword">if</span> (!cred) {
        <span class="comment">// The Twitter account has not logged in to this app before.  Create</span>
        <span class="comment">// new user record and link it to the Twitter account.</span>
        db.run(<span class="string">'INSERT INTO users (name) VALUES (?)'</span>, [
          profile.displayName
        ], <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>{
          <span class="keyword">if</span> (err) { <span class="keyword">return</span> cb(err); }

          <span class="keyword">var</span> id = <span class="keyword">this</span>.lastID;
          db.run(<span class="string">'INSERT INTO federated_credentials (user_id, provider, subject) VALUES (?, ?, ?)'</span>, [
            id,
            <span class="string">'https://twitter.com'</span>,
            profile.id
          ], <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>{
            <span class="keyword">if</span> (err) { <span class="keyword">return</span> cb(err); }
            <span class="keyword">var</span> user = {
              <span class="attr">id</span>: id.toString(),
              <span class="attr">name</span>: profile.displayName
            };
            <span class="keyword">return</span> cb(<span class="literal">null</span>, user);
          });
        });
      } <span class="keyword">else</span> {
        <span class="comment">// The Twitter account has previously logged in to the app.  Get the</span>
        <span class="comment">// user record linked to the Twitter account and log the user in.</span>
        db.get(<span class="string">'SELECT * FROM users WHERE id = ?'</span>, [ cred.user_id ], <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>{
          <span class="keyword">if</span> (err) { <span class="keyword">return</span> cb(err); }
          <span class="keyword">if</span> (!user) { <span class="keyword">return</span> cb(<span class="literal">null</span>, <span class="literal">false</span>); }
          <span class="keyword">return</span> cb(<span class="literal">null</span>, user);
        });
      }
    };
  }
));
</code></pre>
<p>The options to the <code>TwitterStrategy</code> constructor must include a <code>consumerKey</code>
and <code>consumerSecret</code>, the values of which are set to the API key and secret that
were obtained when registering your application.  A <code>callbackURL</code> must also be
included.  Twitter will redirect users to this location after they have
authenticated.  The path of this URL must match the route defined below.</p>
<p>The <code>verify</code> function accepts a <code>token</code>, <code>tokenSecret</code> and <code>profile</code> as
arguments.  <code>token</code> and <code>tokenSecret</code> are used for API access, and are not
needed for authentication.  <code>profile</code> is a <a href="/guide/profile/">normalized</a> profile
containing information provided by Twitter about the user who is signing in.</p>
<p>The <code>verify</code> function is responsible for determining the user to which the
Twitter account belongs.  The first time that account is used to sign in, a new
user record is typically created automatically using profile information
supplied by Twitter, and that record is then linked to the Twitter account.  On
subsequent signins, the existing user record will be found via its relation to
the Twitter account.</p>
<p>Linking social accounts to a user record is recommended, as it allows users to
link multiple social accounts from other providers in the event that they stop
using Twitter.  Alternatively, the user could set up a credential, such as a
password, for their user account at your app.  Either feature allows the user to
continue to sign in to your application independent of their Twitter account.</p>
<p>The example above illustrates usage of a SQL database to find or create a user
record and link it to a Twitter account.  However, because the <code>verify</code> function
is supplied by the application, the application is free to use a database and
schema of its choosing.</p>
<p>Internally, Log in with Twitter is implemented using <a href="https://developer.twitter.com/en/docs/authentication/oauth-1-0a">OAuth 1.0a</a>.
As such, the strategy configuration is able to make use of additional options
and functionality provided by the base <a href="/docs/oauth/">OAuth strategy</a>.</p>
<h2 id="prompt">Prompt</h2>
<p>Place a button on the application&#39;s login page, prompting the user to sign in
with Twitter.</p>
<pre><code class="lang-html"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/login/twitter"</span> <span class="attr">class</span>=<span class="string">"button"</span>&gt;</span>Sign in with Twitter<span class="tag">&lt;/<span class="name">a</span>&gt;</span>
</code></pre>
<p>Define a route that, when the button is clicked, will redirect the user to
Twitter, where they will authenticate.</p>
<pre><code class="lang-javascript">app.get(<span class="string">'/login/twitter'</span>, passport.authenticate(<span class="string">'twitter'</span>));
</code></pre>
<h2 id="authenticate">Authenticate</h2>
<p>After the user has authenticated with Twitter, they will be redirected back to
your application.  Define a route which will handle this redirect.</p>
<pre><code>app.get(<span class="string">'/oauth/callback/twitter'</span>,
  passport.authenticate(<span class="string">'twitter'</span>, { failureRedirect: <span class="string">'/login'</span>, failureMessage: <span class="literal">true</span> }),
  <span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> </span>{
    res.redirect(<span class="string">'/'</span>);
  });
</code></pre><p>When a request to this route is processed, the strategy will authenticate the
fact that the user signed in with Twitter and obtain that user&#39;s profile
information.  If authentication succeeds, <code>passport.authenticate()</code> middleware
calls the next function in the stack.  In this example, the function is
redirecting the authenticated user to the home page.</p>
<p>When authentication fails, the user is re-prompted to sign in and informed that
their initial attempt was not successful.  This is accomplished by using the
<code>failureRedirect</code> option, which will redirect the user to the login page, along
with the <code>failureMessage</code> option which will add the message to
<code>req.session.messages</code>.</p>
<p>The path of this route should be the value supplied for the <code>callbackURL</code> option
in the strategy configuration above.</p>
</section><section class="chapter" id="google"><h1 id="google">Google</h1>
<p><a href="https://developers.google.com/identity">Sign In With Google</a> allows users to
sign in using their Google account.  Support for Sign In With Google is
provided by the <a href="https://github.com/jaredhanson/passport-google-openidconnect"><code>passport-google-oidc</code></a>
package.</p>
<h2 id="install">Install</h2>
<p>To install <code>passport-google-oidc</code>, execute the following command:</p>
<pre><code class="lang-bash">$ npm install passport-google-oidc
</code></pre>
<h2 id="configure">Configure</h2>
<p>Before your application can make use of Sign In With Google, you must register
your app with Google.  This can be done in the <a href="https://console.cloud.google.com/apis">APIs &amp; Services</a>
page of the <a href="https://console.cloud.google.com/">Google Cloud Platform console</a>.
Once registered, your app will be issued a client ID and secret which will be
used in the strategy configuration.</p>
<p>The following code is an example that configures and registers the
<code>GoogleStrategy</code>:</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>);
<span class="keyword">var</span> GoogleStrategy = <span class="built_in">require</span>(<span class="string">'passport-google-oidc'</span>);

passport.use(<span class="keyword">new</span> GoogleStrategy({
    <span class="attr">clientID</span>: process.env[<span class="string">'GOOGLE_CLIENT_ID'</span>],
    <span class="attr">clientSecret</span>: process.env[<span class="string">'GOOGLE_CLIENT_SECRET'</span>],
    <span class="attr">callbackURL</span>: <span class="string">'https://www.example.com/oauth2/redirect/google'</span>
  },
  <span class="function"><span class="keyword">function</span>(<span class="params">issuer, profile, cb</span>) </span>{
    db.get(<span class="string">'SELECT * FROM federated_credentials WHERE provider = ? AND subject = ?'</span>, [
      issuer,
      profile.id
    ], <span class="function"><span class="keyword">function</span>(<span class="params">err, cred</span>) </span>{
      <span class="keyword">if</span> (err) { <span class="keyword">return</span> cb(err); }
      <span class="keyword">if</span> (!cred) {
        <span class="comment">// The Google account has not logged in to this app before.  Create a</span>
        <span class="comment">// new user record and link it to the Google account.</span>
        db.run(<span class="string">'INSERT INTO users (name) VALUES (?)'</span>, [
          profile.displayName
        ], <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>{
          <span class="keyword">if</span> (err) { <span class="keyword">return</span> cb(err); }

          <span class="keyword">var</span> id = <span class="keyword">this</span>.lastID;
          db.run(<span class="string">'INSERT INTO federated_credentials (user_id, provider, subject) VALUES (?, ?, ?)'</span>, [
            id,
            issuer,
            profile.id
          ], <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>{
            <span class="keyword">if</span> (err) { <span class="keyword">return</span> cb(err); }
            <span class="keyword">var</span> user = {
              <span class="attr">id</span>: id.toString(),
              <span class="attr">name</span>: profile.displayName
            };
            <span class="keyword">return</span> cb(<span class="literal">null</span>, user);
          });
        });
      } <span class="keyword">else</span> {
        <span class="comment">// The Google account has previously logged in to the app.  Get the</span>
        <span class="comment">// user record linked to the Google account and log the user in.</span>
        db.get(<span class="string">'SELECT * FROM users WHERE id = ?'</span>, [ cred.user_id ], <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>{
          <span class="keyword">if</span> (err) { <span class="keyword">return</span> cb(err); }
          <span class="keyword">if</span> (!user) { <span class="keyword">return</span> cb(<span class="literal">null</span>, <span class="literal">false</span>); }
          <span class="keyword">return</span> cb(<span class="literal">null</span>, user);
        });
      }
    };
  }
));
</code></pre>
<p>The options to the <code>GoogleStrategy</code> constructor must include a <code>clientID</code> and
<code>clientSecret</code>, the values of which are set to the client ID and secret that
were obtained when registering your application.  A <code>callbackURL</code> must also be
included.  Google will redirect users to this location after they have
authenticated.  The path of this URL must match the route defined below.</p>
<p>The <code>verify</code> function accepts <code>issuer</code> and <code>profile</code> as arguments.  <code>issuer</code> is
set to <code>&quot;https://accounts.google.com&quot;</code>, indicating that the user signed in with
Google.  <code>profile</code> is a <a href="/guide/profile/">normalized</a> profile containing
information provided by Google about the user who is signing in.</p>
<p>The <code>verify</code> function is responsible for determining the user to which the
Google account belongs.  The first time that account is used to sign in, a new
user record is typically created automatically using profile information
supplied by Google, and that record is then linked to the Google account.  On
subsequent signins, the existing user record will be found via its relation to
the Google account.</p>
<p>Linking social accounts to a user record is recommended, as it allows users to
link multiple social accounts from other providers in the event that they stop
using Google.  Alternatively, the user could set up a credential, such as a
password, for their user account at your app.  Either feature allows the user to
continue to sign in to your application independent of their Google account.</p>
<p>The example above illustrates usage of a SQL database to find or create a user
record and link it to a Google account.  However, because the <code>verify</code> function
is supplied by the application, the application is free to use a database and
schema of its choosing.</p>
<p>Internally, Sign In With Google is implemented using <a href="https://developers.google.com/identity/protocols/oauth2/openid-connect">OpenID Connect</a>.
As such, the strategy configuration is able to make use of additional options
and functionality provided by the base OpenID Connect strategy.</p>
<h2 id="prompt">Prompt</h2>
<p>Place a button on the application&#39;s login page, prompting the user to sign in
with Google.</p>
<pre><code class="lang-html"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/login/google"</span> <span class="attr">class</span>=<span class="string">"button"</span>&gt;</span>Sign in with Google<span class="tag">&lt;/<span class="name">a</span>&gt;</span>
</code></pre>
<p>Define a route that, when the button is clicked, will redirect the user to
Google, where they will authenticate.</p>
<pre><code class="lang-javascript">app.get(<span class="string">'/login/google'</span>, passport.authenticate(<span class="string">'google'</span>));
</code></pre>
<p>If your application needs additional information about the user, that can be
requested with the <code>scope</code> option:</p>
<pre><code class="lang-javascript">app.get(<span class="string">'/login/google'</span>, passport.authenticate(<span class="string">'google'</span>, {
  <span class="attr">scope</span>: [ <span class="string">'email'</span> ]
}));
</code></pre>
<h2 id="authenticate">Authenticate</h2>
<p>After the user has authenticated with Google, they will be redirected back
to your application.  Define a route which will handle this redirect.</p>
<pre><code>app.get(<span class="string">'/oauth2/redirect/google'</span>,
  passport.authenticate(<span class="string">'google'</span>, { failureRedirect: <span class="string">'/login'</span>, failureMessage: <span class="literal">true</span> }),
  <span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> </span>{
    res.redirect(<span class="string">'/'</span>);
  });
</code></pre><p>When a request to this route is processed, the strategy will authenticate the
fact that the user signed in with Google and obtain that user&#39;s profile
information.  If authentication succeeds, <code>passport.authenticate()</code> middleware
calls the next function in the stack.  In this example, the function is
redirecting the authenticated user to the home page.</p>
<p>When authentication fails, the user is re-prompted to sign in and informed that
their initial attempt was not successful.  This is accomplished by using the
<code>failureRedirect</code> option, which will redirect the user to the login page, along
with the <code>failureMessage</code> option which will add the message to
<code>req.session.messages</code>.</p>
<p>The path of this route should be the value supplied for the <code>callbackURL</code> option
in the strategy configuration above.</p>
</section><section class="chapter" id="http-basic"><h1 id="basic-digest">Basic &amp; Digest</h1>
<p>Along with defining HTTP&#39;s authentication framework, <a href="http://tools.ietf.org/html/rfc2617">RFC 2617</a>
also defined the Basic and Digest authentications schemes.  These two schemes
both use usernames and passwords as credentials to authenticate users, and are
often used to protect API endpoints.</p>
<p>It should be noted that relying on username and password credentials can have
adverse security impacts, especially in scenarios where there is not a high
degree of trust between the server and client.  In these situations, it is
recommended to use an authorization framework such as <a href="/guide/oauth2-api/">OAuth 2.0</a>.</p>
<p>Support for Basic and Digest schemes is provided by the <a href="https://github.com/jaredhanson/passport-http">passport-http</a>
module.</p>
<h2 id="install">Install</h2>
<pre><code class="lang-bash">$ npm install passport-http
</code></pre>
<h3 id="basic">Basic</h3>
<p>The Basic scheme uses a username and password to authenticate a user.  These
credentials are transported in plain text, so it is advised to use HTTPS when
implementing this scheme.</p>
<h2 id="configuration">Configuration</h2>
<pre><code class="lang-javascript">passport.use(<span class="keyword">new</span> BasicStrategy(
  <span class="function"><span class="keyword">function</span>(<span class="params">username, password, done</span>) </span>{
    User.findOne({ <span class="attr">username</span>: username }, <span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>{
      <span class="keyword">if</span> (err) { <span class="keyword">return</span> done(err); }
      <span class="keyword">if</span> (!user) { <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="literal">false</span>); }
      <span class="keyword">if</span> (!user.validPassword(password)) { <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="literal">false</span>); }
      <span class="keyword">return</span> done(<span class="literal">null</span>, user);
    });
  }
));
</code></pre>
<p>The verify callback for Basic authentication accepts <code>username</code> and <code>password</code>
arguments.</p>
<h2 id="protect-endpoints">Protect Endpoints</h2>
<pre><code class="lang-javascript">app.get(<span class="string">'/api/me'</span>,
  passport.authenticate(<span class="string">'basic'</span>, { <span class="attr">session</span>: <span class="literal">false</span> }),
  <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>{
    res.json(req.user);
  });
</code></pre>
<p>Specify <code>passport.authenticate()</code> with the <code>basic</code> strategy to protect API
endpoints.  Sessions are not typically needed by APIs, so they can be disabled.</p>
<h3 id="digest">Digest</h3>
<p>The Digest scheme uses a username and password to authenticate a user.  Its
primary benefit over Basic is that it uses a challenge-response paradigm to
avoid sending the password in the clear.</p>
<h2 id="configuration">Configuration</h2>
<pre><code class="lang-javascript">passport.use(<span class="keyword">new</span> DigestStrategy({ <span class="attr">qop</span>: <span class="string">'auth'</span> },
  <span class="function"><span class="keyword">function</span>(<span class="params">username, done</span>) </span>{
    User.findOne({ <span class="attr">username</span>: username }, <span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>{
      <span class="keyword">if</span> (err) { <span class="keyword">return</span> done(err); }
      <span class="keyword">if</span> (!user) { <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="literal">false</span>); }
      <span class="keyword">return</span> done(<span class="literal">null</span>, user, user.password);
    });
  },
  <span class="function"><span class="keyword">function</span>(<span class="params">params, done</span>) </span>{
    <span class="comment">// validate nonces as necessary</span>
    done(<span class="literal">null</span>, <span class="literal">true</span>)
  }
));
</code></pre>
<p>The Digest strategy utilizes two callbacks, the second of which is optional.</p>
<p>The first callback, known as the &quot;secret callback&quot; accepts the username and
calls <code>done</code> supplying a user and the corresponding secret password.  The
password is used to compute a hash, and authentication fails if it does not
match that contained in the request.</p>
<p>The second &quot;validate callback&quot; accepts nonce related params, which can be
checked to avoid replay attacks.</p>
<h2 id="protect-endpoints">Protect Endpoints</h2>
<pre><code class="lang-javascript">app.get(<span class="string">'/api/me'</span>,
  passport.authenticate(<span class="string">'digest'</span>, { <span class="attr">session</span>: <span class="literal">false</span> }),
  <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>{
    res.json(req.user);
  });
</code></pre>
<p>Specify <code>passport.authenticate()</code> with the <code>digest</code> strategy to protect API
endpoints.  Sessions are not typically needed by APIs, so they can be disabled.</p>
</section><section class="chapter" id="http-oauth"><h1 id="oauth">OAuth</h1>
<p><a href="http://oauth.net/">OAuth</a> (formally specified by <a href="http://tools.ietf.org/html/rfc5849">RFC 5849</a>)
provides a means for users to grant third-party applications access to their
data without exposing their password to those applications.</p>
<p>The protocol greatly improves the security of web applications, in particular,
and OAuth has been important in bringing attention to the potential dangers of
exposing passwords to external services.</p>
<p>While OAuth 1.0 is still widely used, it has been superseded by <a href="/guide/oauth2-api/">OAuth 2.0</a>.
It is recommended to base new implementations on OAuth 2.0.</p>
<p>When using OAuth to protect API endpoints, there are three distinct steps that
that must be performed:</p>
<ol>
<li>The application requests permission from the user for access to protected
resources.</li>
<li>A token is issued to the application, if permission is granted by the user.</li>
<li>The application authenticates using the token to access protected
resources.</li>
</ol>
<h2 id="issuing-tokens">Issuing Tokens</h2>
<p><a href="https://github.com/jaredhanson/oauthorize">OAuthorize</a>, a sibling project to
Passport, provides a toolkit for implementing OAuth service providers.</p>
<p>The authorization process is a complex sequence that involves authenticating
both the requesting application and the user, as well as prompting the user for
permission, ensuring that enough detail is provided for the user to make an
informed decision.</p>
<p>Additionally, it is up to the implementor to determine what limits can be placed
on the application regarding scope of access, as well as subsequently enforcing
those limits.</p>
<p>As a toolkit, OAuthorize does not attempt to make implementation decisions.
This guide does not cover these issues, but does highly recommend that
services deploying OAuth have a complete understanding of the security
considerations involved.</p>
<h2 id="authenticating-tokens">Authenticating Tokens</h2>
<p>Once issued, OAuth tokens can be authenticated using the <a href="https://github.com/jaredhanson/passport-http-oauth">passport-http-oauth</a>
module.</p>
<h2 id="install">Install</h2>
<pre><code class="lang-bash">$ npm install passport-http-oauth
</code></pre>
<h2 id="configuration">Configuration</h2>
<pre><code class="lang-javascript">passport.use(<span class="string">'token'</span>, <span class="keyword">new</span> TokenStrategy(
  <span class="function"><span class="keyword">function</span>(<span class="params">consumerKey, done</span>) </span>{
    Consumer.findOne({ <span class="attr">key</span>: consumerKey }, <span class="function"><span class="keyword">function</span> (<span class="params">err, consumer</span>) </span>{
      <span class="keyword">if</span> (err) { <span class="keyword">return</span> done(err); }
      <span class="keyword">if</span> (!consumer) { <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="literal">false</span>); }
      <span class="keyword">return</span> done(<span class="literal">null</span>, consumer, consumer.secret);
    });
  },
  <span class="function"><span class="keyword">function</span>(<span class="params">accessToken, done</span>) </span>{
    AccessToken.findOne({ <span class="attr">token</span>: accessToken }, <span class="function"><span class="keyword">function</span> (<span class="params">err, token</span>) </span>{
      <span class="keyword">if</span> (err) { <span class="keyword">return</span> done(err); }
      <span class="keyword">if</span> (!token) { <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="literal">false</span>); }
      Users.findById(token.userId, <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>{
        <span class="keyword">if</span> (err) { <span class="keyword">return</span> done(err); }
        <span class="keyword">if</span> (!user) { <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="literal">false</span>); }
        <span class="comment">// fourth argument is optional info.  typically used to pass</span>
        <span class="comment">// details needed to authorize the request (ex: `scope`)</span>
        <span class="keyword">return</span> done(<span class="literal">null</span>, user, token.secret, { <span class="attr">scope</span>: token.scope });
      });
    });
  },
  <span class="function"><span class="keyword">function</span>(<span class="params">timestamp, nonce, done</span>) </span>{
    <span class="comment">// validate the timestamp and nonce as necessary</span>
    done(<span class="literal">null</span>, <span class="literal">true</span>)
  }
));
</code></pre>
<p>In contrast to other strategies, there are two callbacks required by OAuth.  In
OAuth, both an identifier for the requesting application and the user-specific
token are encoded as credentials.</p>
<p>The first callback is known as the &quot;consumer callback&quot;, and is used to find the
application making the request, including the secret assigned to it.  The second
callback is the &quot;token callback&quot;, which is used to identify the user as well as
the token&#39;s corresponding secret.  The secrets supplied by the consumer and
token callbacks are used to compute a signature, and authentication fails if it
does not match the request signature.</p>
<p>A final &quot;validate callback&quot; is optional, which can be used to prevent replay
attacks by checking the timestamp and nonce used in the request.</p>
<h2 id="protect-endpoints">Protect Endpoints</h2>
<pre><code class="lang-javascript">app.get(<span class="string">'/api/me'</span>,
  passport.authenticate(<span class="string">'token'</span>, { <span class="attr">session</span>: <span class="literal">false</span> }),
  <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>{
    res.json(req.user);
  });
</code></pre>
<p>Specify <code>passport.authenticate()</code> with the <code>token</code> strategy to protect API
endpoints.  Sessions are not typically needed by APIs, so they can be disabled.</p>
</section><section class="chapter" id="http-bearer"><h1 id="oauth-2-0">OAuth 2.0</h1>
<p>OAuth 2.0 (formally specified by <a href="http://tools.ietf.org/html/rfc6749">RFC 6749</a>)
provides an authorization framework which allows users to authorize access to
third-party applications.  When authorized, the application is issued a token to
use as an authentication credential.  This has two primary security benefits:</p>
<ol>
<li>The application does not need to store the user&#39;s username and password.</li>
<li>The token can have a restricted scope (for example: read-only access).</li>
</ol>
<p>These benefits are particularly important for ensuring the security of web
applications, making OAuth 2.0 the predominant standard for API authentication.</p>
<p>When using OAuth 2.0 to protect API endpoints, there are three distinct steps
that must be performed:</p>
<ol>
<li>The application requests permission from the user for access to protected
resources.</li>
<li>A token is issued to the application, if permission is granted by the user.</li>
<li>The application authenticates using the token to access protected
resources.</li>
</ol>
<h2 id="issuing-tokens">Issuing Tokens</h2>
<p><a href="https://github.com/jaredhanson/oauth2orize">OAuth2orize</a>, a sibling project to
Passport, provides a toolkit for implementing OAuth 2.0 authorization servers.</p>
<p>The authorization process is a complex sequence that involves authenticating
both the requesting application and the user, as well as prompting the user for
permission, ensuring that enough detail is provided for the user to make an
informed decision.</p>
<p>Additionally, it is up to the implementor to determine what limits can be placed
on the application regarding scope of access, as well as subsequently enforcing
those limits.</p>
<p>As a toolkit, OAuth2orize does not attempt to make implementation decisions.
This guide does not cover these issues, but does highly recommend that
services deploying OAuth 2.0 have a complete understanding of the security
considerations involved.</p>
<h2 id="authenticating-tokens">Authenticating Tokens</h2>
<p>OAuth 2.0 provides a framework, in which an arbitrarily extensible set of token
types can be issued.  In practice, only specific token types have gained
widespread use.</p>
<h2 id="bearer-tokens">Bearer Tokens</h2>
<p>Bearer tokens are the most widely issued type of token in OAuth 2.0.  So much
so, in fact, that many implementations assume that bearer tokens are the only
type of token issued.</p>
<p>Bearer tokens can be authenticated using the <a href="https://github.com/jaredhanson/passport-http-bearer">passport-http-bearer</a>
module.</p>
<h2 id="install">Install</h2>
<pre><code class="lang-bash">$ npm install passport-http-bearer
</code></pre>
<h2 id="configuration">Configuration</h2>
<pre><code class="lang-javascript">passport.use(<span class="keyword">new</span> BearerStrategy(
  <span class="function"><span class="keyword">function</span>(<span class="params">token, done</span>) </span>{
    User.findOne({ <span class="attr">token</span>: token }, <span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>{
      <span class="keyword">if</span> (err) { <span class="keyword">return</span> done(err); }
      <span class="keyword">if</span> (!user) { <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="literal">false</span>); }
      <span class="keyword">return</span> done(<span class="literal">null</span>, user, { <span class="attr">scope</span>: <span class="string">'read'</span> });
    });
  }
));
</code></pre>
<p>The verify callback for bearer tokens accepts the <code>token</code> as an argument.
When invoking <code>done</code>, optional <code>info</code> can be passed, which will be set by
Passport at <code>req.authInfo</code>.  This is typically used to convey the scope of the
token, and can be used when making access control checks.</p>
<h2 id="protect-endpoints">Protect Endpoints</h2>
<pre><code class="lang-javascript">app.get(<span class="string">'/api/me'</span>,
  passport.authenticate(<span class="string">'bearer'</span>, { <span class="attr">session</span>: <span class="literal">false</span> }),
  <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>{
    res.json(req.user);
  });
</code></pre>
<p>Specify <code>passport.authenticate()</code> with the <code>bearer</code> strategy to protect API
endpoints.  Sessions are not typically needed by APIs, so they can be disabled.</p>
</section><section class="chapter" id="login"><h1 id="log-in">Log In</h1>
<p>Passport exposes a <code>login()</code> function on <code>req</code> (also aliased as <code>logIn()</code>) that
can be used to establish a login session.</p>
<pre><code class="lang-javascript">req.login(user, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>{
  <span class="keyword">if</span> (err) { <span class="keyword">return</span> next(err); }
  <span class="keyword">return</span> res.redirect(<span class="string">'/users/'</span> + req.user.username);
});
</code></pre>
<p>When the login operation completes, <code>user</code> will be assigned to <code>req.user</code>.</p>
<p>Note: <code>passport.authenticate()</code> middleware invokes <code>req.login()</code> automatically.
This function is primarily used when users sign up, during which <code>req.login()</code>
can be invoked to automatically log in the newly registered user.</p>
</section><section class="chapter" id="logout"><h1 id="log-out">Log Out</h1>
<p>Passport exposes a <code>logout()</code> function on <code>req</code> (also aliased as <code>logOut()</code>)
that can be called from any route handler which needs to terminate a login
session.  Invoking <code>logout()</code> will remove the <code>req.user</code> property and clear the
login session (if any).</p>
<p>It is a good idea to use POST or DELETE requests instead of GET requests for the 
logout endpoints, in order to prevent accidental or malicious logouts.</p>
<pre><code class="lang-javascript">app.post(<span class="string">'/logout'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>{
  req.logout();
  res.redirect(<span class="string">'/'</span>);
});
</code></pre>
</section></div>
        </div>
      </div>
    </div>
    <div class="search-con">
      <div class="head"><span class="close-ico"></span>
        <div class="hold">
          <h2>SEARCH FOR STRATEGIES</h2>
          <form action="/">
            <input value="" type="text" name="strategy" placeholder="Start typing" autocomplete="off">
          </form>
          <p class="info-line"><span>0</span>STRATEGIES</p>
        </div>
      </div>
      <div class="results">
        <section></section>
      </div>
    </div>
    <!--+google-tag-manager-noscript('GTM-M5S3PH')-->
  </body>
</html>